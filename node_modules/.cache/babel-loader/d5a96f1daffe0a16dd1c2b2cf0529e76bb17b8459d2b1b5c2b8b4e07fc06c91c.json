{"ast":null,"code":"import tracks from './tracks';\nexport function gridDistance(posA, posB) {\n  // The Pacman board is a kind of manhattan style map, with constraints\n  // due to walls\n  return Math.abs(posA[0] - posB[0]) + Math.abs(posA[1] - posB[1]);\n}\nexport function orderPolarity(direction) {\n  var order = (direction < 2) >> 0;\n  var polarity = Math.pow(-1, 1 - order);\n  var plane = direction % 2;\n  return {\n    order: order,\n    polarity: polarity,\n    plane: plane\n  };\n}\nexport function getNewPosition(position, direction, speed, time) {\n  var toNearestPlane = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var _orderPolarity = orderPolarity(direction),\n    order = _orderPolarity.order,\n    plane = _orderPolarity.plane,\n    polarity = _orderPolarity.polarity;\n  var newPosition = position.slice();\n  var movedVector = polarity * speed * time;\n  var movedDistance = Math.abs(movedVector);\n  var nearestOtherPlane = Math.round(newPosition[1 - plane]);\n  if (toNearestPlane) {\n    newPosition[1 - plane] = nearestOtherPlane;\n  }\n  newPosition[plane] += movedVector;\n  var track = tracks[plane][nearestOtherPlane];\n  var trackHit = track.findIndex(function (limits) {\n    return position[plane] >= limits[0] && position[plane] <= limits[1] && polarity * newPosition[plane] > polarity * limits[order];\n  });\n  var collision = false;\n  if (trackHit === (track.length - 1) * order && track[trackHit][2]) {\n    // wrap\n    newPosition[plane] = track[(track.length - 1) * (1 - order)][1 - order];\n    movedDistance = speed * time;\n  } else if (trackHit > -1) {\n    newPosition[plane] = track[trackHit][order];\n    movedDistance = Math.abs(position[plane] - track[trackHit][order]);\n    collision = true;\n  }\n  return {\n    newPosition: newPosition,\n    collision: collision,\n    movedDistance: movedDistance\n  };\n}\nexport function snapToTrack(plane, order, position, tolerance) {\n  var snap = order ? Math.ceil(position[plane]) : Math.floor(position[plane]);\n  if (Math.abs(snap - position[plane]) > tolerance) {\n    return -1;\n  }\n  return snap;\n}\nexport function getChangedVector(oldPosition, newPosition, oldDirection, newDirection, movedDistance) {\n  var _orderPolarity2 = orderPolarity(oldDirection),\n    oldPlane = _orderPolarity2.plane,\n    oldOrder = _orderPolarity2.order;\n  var trackTo = snapToTrack(oldPlane, oldOrder, newPosition, movedDistance);\n  if (trackTo === -1) {\n    return null;\n  }\n  var old0 = oldPosition[oldPlane];\n  var new0 = newPosition[oldPlane];\n  var movedDistanceBeforeTurn = Math.abs(trackTo - newPosition[oldPlane]);\n  if (!(old0 === new0 && movedDistanceBeforeTurn > movedDistance)) {\n    var _orderPolarity3 = orderPolarity(newDirection),\n      newOrder = _orderPolarity3.order,\n      newPlane = _orderPolarity3.plane,\n      polarity = _orderPolarity3.polarity;\n    var track = tracks[newPlane][trackTo];\n    if (!track) {\n      return null;\n    }\n    var trackHit = track.findIndex(function (limits) {\n      return newPosition[newPlane] >= limits[0] && newPosition[newPlane] <= limits[1] && (1 - newOrder) * newPosition[newPlane] >= (limits[0] - polarity) * (1 - newOrder) && newOrder * newPosition[newPlane] <= (limits[1] - polarity) * newOrder;\n    });\n    if (trackHit > -1) {\n      var changedVector = newPosition.slice();\n      changedVector[oldPlane] = trackTo;\n      changedVector[newPlane] += polarity * (movedDistance - movedDistanceBeforeTurn);\n      return changedVector;\n    }\n  }\n  return null;\n}","map":{"version":3,"names":["tracks","gridDistance","posA","posB","Math","abs","orderPolarity","direction","order","polarity","pow","plane","getNewPosition","position","speed","time","toNearestPlane","arguments","length","undefined","_orderPolarity","newPosition","slice","movedVector","movedDistance","nearestOtherPlane","round","track","trackHit","findIndex","limits","collision","snapToTrack","tolerance","snap","ceil","floor","getChangedVector","oldPosition","oldDirection","newDirection","_orderPolarity2","oldPlane","oldOrder","trackTo","old0","new0","movedDistanceBeforeTurn","_orderPolarity3","newOrder","newPlane","changedVector"],"sources":["/Users/lordsmac/Documents/Dev/React_Play_Ground/Dashboard/Portfolio/portfolio/node_modules/react-pacman/dist/game/movement.js"],"sourcesContent":["import tracks from './tracks';\nexport function gridDistance(posA, posB) {\n  // The Pacman board is a kind of manhattan style map, with constraints\n  // due to walls\n  return Math.abs(posA[0] - posB[0]) + Math.abs(posA[1] - posB[1]);\n}\nexport function orderPolarity(direction) {\n  var order = (direction < 2) >> 0;\n  var polarity = Math.pow(-1, 1 - order);\n  var plane = direction % 2;\n  return {\n    order: order,\n    polarity: polarity,\n    plane: plane\n  };\n}\nexport function getNewPosition(position, direction, speed, time) {\n  var toNearestPlane = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n  var _orderPolarity = orderPolarity(direction),\n      order = _orderPolarity.order,\n      plane = _orderPolarity.plane,\n      polarity = _orderPolarity.polarity;\n\n  var newPosition = position.slice();\n  var movedVector = polarity * speed * time;\n  var movedDistance = Math.abs(movedVector);\n  var nearestOtherPlane = Math.round(newPosition[1 - plane]);\n\n  if (toNearestPlane) {\n    newPosition[1 - plane] = nearestOtherPlane;\n  }\n\n  newPosition[plane] += movedVector;\n  var track = tracks[plane][nearestOtherPlane];\n  var trackHit = track.findIndex(function (limits) {\n    return position[plane] >= limits[0] && position[plane] <= limits[1] && polarity * newPosition[plane] > polarity * limits[order];\n  });\n  var collision = false;\n\n  if (trackHit === (track.length - 1) * order && track[trackHit][2]) {\n    // wrap\n    newPosition[plane] = track[(track.length - 1) * (1 - order)][1 - order];\n    movedDistance = speed * time;\n  } else if (trackHit > -1) {\n    newPosition[plane] = track[trackHit][order];\n    movedDistance = Math.abs(position[plane] - track[trackHit][order]);\n    collision = true;\n  }\n\n  return {\n    newPosition: newPosition,\n    collision: collision,\n    movedDistance: movedDistance\n  };\n}\nexport function snapToTrack(plane, order, position, tolerance) {\n  var snap = order ? Math.ceil(position[plane]) : Math.floor(position[plane]);\n\n  if (Math.abs(snap - position[plane]) > tolerance) {\n    return -1;\n  }\n\n  return snap;\n}\nexport function getChangedVector(oldPosition, newPosition, oldDirection, newDirection, movedDistance) {\n  var _orderPolarity2 = orderPolarity(oldDirection),\n      oldPlane = _orderPolarity2.plane,\n      oldOrder = _orderPolarity2.order;\n\n  var trackTo = snapToTrack(oldPlane, oldOrder, newPosition, movedDistance);\n\n  if (trackTo === -1) {\n    return null;\n  }\n\n  var old0 = oldPosition[oldPlane];\n  var new0 = newPosition[oldPlane];\n  var movedDistanceBeforeTurn = Math.abs(trackTo - newPosition[oldPlane]);\n\n  if (!(old0 === new0 && movedDistanceBeforeTurn > movedDistance)) {\n    var _orderPolarity3 = orderPolarity(newDirection),\n        newOrder = _orderPolarity3.order,\n        newPlane = _orderPolarity3.plane,\n        polarity = _orderPolarity3.polarity;\n\n    var track = tracks[newPlane][trackTo];\n\n    if (!track) {\n      return null;\n    }\n\n    var trackHit = track.findIndex(function (limits) {\n      return newPosition[newPlane] >= limits[0] && newPosition[newPlane] <= limits[1] && (1 - newOrder) * newPosition[newPlane] >= (limits[0] - polarity) * (1 - newOrder) && newOrder * newPosition[newPlane] <= (limits[1] - polarity) * newOrder;\n    });\n\n    if (trackHit > -1) {\n      var changedVector = newPosition.slice();\n      changedVector[oldPlane] = trackTo;\n      changedVector[newPlane] += polarity * (movedDistance - movedDistanceBeforeTurn);\n      return changedVector;\n    }\n  }\n\n  return null;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}