{"ast":null,"code":"var _excluded = [\"lost\"];\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nimport * as constants from '../constants';\nimport tracks from './tracks';\nimport { gridDistance, orderPolarity, getNewPosition, snapToTrack } from './movement';\nfunction getAvailableVectors(_ref) {\n  var newPosition = _ref.newPosition,\n    plane = _ref.plane,\n    trackTo = _ref.trackTo,\n    distanceFromTrack = _ref.distanceFromTrack,\n    movedDistance = _ref.movedDistance,\n    availableOptions = _ref.availableOptions,\n    player = _ref.player,\n    eating = _ref.eating;\n  return availableOptions.map(function (direction) {\n    var _orderPolarity = orderPolarity(direction),\n      optionPolarity = _orderPolarity.polarity,\n      optionPlane = _orderPolarity.plane;\n    var position = null;\n    if (plane === optionPlane) {\n      position = newPosition;\n    } else {\n      position = [];\n      position[optionPlane] = newPosition[optionPlane] + Math.max(0, movedDistance - distanceFromTrack) * optionPolarity;\n      position[1 - optionPlane] = trackTo;\n    }\n    var compare = [];\n    compare[optionPlane] = newPosition[optionPlane] + optionPolarity;\n    compare[1 - optionPlane] = position[1 - optionPlane];\n    return {\n      compare: compare,\n      position: position,\n      direction: direction\n    };\n  }).sort(function (_ref2, _ref3) {\n    var posA = _ref2.compare;\n    var posB = _ref3.compare;\n    return Math.pow(-1, eating >> 0) * (gridDistance(posA, player.position) - gridDistance(posB, player.position));\n  }).map(function (_ref4) {\n    var direction = _ref4.direction,\n      position = _ref4.position;\n    return {\n      direction: direction,\n      position: position\n    };\n  });\n}\nfunction getNextMonsterHomePosition(newPosition, monster, player) {\n  if (monster.direction === constants.EAST && monster.position[0] < constants.MONSTER_HOME_EXIT_COL && newPosition[0] >= constants.MONSTER_HOME_EXIT_COL || monster.direction === constants.WEST && monster.position[0] > constants.MONSTER_HOME_EXIT_COL && newPosition[0] <= constants.MONSTER_HOME_EXIT_COL) {\n    return {\n      position: [constants.MONSTER_HOME_EXIT_COL, newPosition[1]],\n      direction: constants.NORTH\n    };\n  }\n  if (monster.direction === constants.NORTH && monster.position[1] < constants.MONSTER_HOME_RANGE[constants.NORTH] && newPosition[1] >= constants.MONSTER_HOME_RANGE[constants.NORTH]) {\n    return {\n      position: [newPosition[0], constants.MONSTER_HOME_RANGE[constants.NORTH]],\n      direction: !monster.directionBias && monster.position[0] < player.position[0] ? constants.EAST : constants.WEST\n    };\n  }\n  return {\n    position: newPosition\n  };\n}\nfunction getIsHome(monster) {\n  return monster.position[0] > constants.MONSTER_HOME_RANGE[constants.WEST] && monster.position[0] < constants.MONSTER_HOME_RANGE[constants.EAST] && monster.position[1] > constants.MONSTER_HOME_RANGE[constants.SOUTH] && monster.position[1] < constants.MONSTER_HOME_RANGE[constants.NORTH];\n}\nfunction getAvailableMonsterRoutes(_ref5) {\n  var newPosition = _ref5.newPosition,\n    collision = _ref5.collision,\n    plane = _ref5.plane,\n    trackTo = _ref5.trackTo,\n    monster = _ref5.monster;\n  var availableOptions = [];\n  var distanceFromTrack = 0;\n  if (trackTo !== -1 && tracks[1 - plane][trackTo]) {\n    var passedTrack = tracks[1 - plane][trackTo].find(function (_ref6) {\n      var _ref7 = _slicedToArray(_ref6, 2),\n        start = _ref7[0],\n        end = _ref7[1];\n      return newPosition[1 - plane] >= start && newPosition[1 - plane] <= end;\n    });\n    var options = [null, null];\n    if (passedTrack[0] < newPosition[1 - plane]) {\n      options[0] = plane === 0 ? constants.SOUTH : constants.WEST;\n    }\n    if (passedTrack[1] > newPosition[1 - plane]) {\n      options[1] = plane === 0 ? constants.NORTH : constants.EAST;\n    }\n    availableOptions = options.filter(function (item) {\n      return item !== null;\n    });\n    distanceFromTrack = Math.abs(newPosition[plane] - trackTo);\n  }\n  if (!collision) {\n    availableOptions.push(monster.direction);\n  }\n  return {\n    availableOptions: availableOptions,\n    distanceFromTrack: distanceFromTrack\n  };\n}\nfunction getNavigatedMonsterVector(newPosition, collision, movedDistance, monster, player) {\n  // determine where to move a monster if it has a decision to make\n  var _orderPolarity2 = orderPolarity(monster.direction),\n    order = _orderPolarity2.order,\n    plane = _orderPolarity2.plane;\n  var trackTo = snapToTrack(plane, order, newPosition, movedDistance);\n  if (trackTo === -1 && collision) {\n    throw new Error('Collided but nothing to track to');\n  }\n  var _getAvailableMonsterR = getAvailableMonsterRoutes({\n      newPosition: newPosition,\n      collision: collision,\n      plane: plane,\n      trackTo: trackTo,\n      monster: monster\n    }),\n    availableOptions = _getAvailableMonsterR.availableOptions,\n    distanceFromTrack = _getAvailableMonsterR.distanceFromTrack;\n  if (!availableOptions.length) {\n    // this happens when wrapping\n    return {\n      position: newPosition\n    };\n  }\n  var vectors = getAvailableVectors({\n    newPosition: newPosition,\n    plane: plane,\n    trackTo: trackTo,\n    distanceFromTrack: distanceFromTrack,\n    movedDistance: movedDistance,\n    availableOptions: availableOptions,\n    player: player,\n    eating: monster.eatingTime > 0\n  });\n  var distanceFromPlayer = gridDistance(vectors[0].position, player.position);\n  if (distanceFromPlayer < constants.PLAYER_RADIUS * 1.8) {\n    if (monster.eatingTime) {\n      // monster got eaten\n      return {\n        deadTime: constants.MONSTER_DEATH_TIME_SECONDS\n      };\n    } // player got eaten\n\n    return {\n      lost: true\n    };\n  }\n  return vectors[0];\n}\nfunction getNewMonsterVector(monster, player, time) {\n  if (monster.deadTime > time) {\n    return _objectSpread(_objectSpread({}, monster), {}, {\n      deadTime: monster.deadTime - time\n    });\n  }\n  if (monster.deadTime > 0) {\n    return _objectSpread(_objectSpread({}, monster), {}, {\n      deadTime: 0,\n      eatingTime: 0,\n      position: monster.startingPosition,\n      direction: monster.startingDirection\n    });\n  }\n  var eatingTime = Math.max(0, monster.eatingTime - time);\n  var isHome = getIsHome(monster);\n  var speed = monster.eatingTime ? constants.MONSTER_SPEED_RETREAT : constants.MONSTER_SPEED_ATTACK;\n  try {\n    var _getNewPosition = getNewPosition(monster.position, monster.direction, speed, time, !isHome),\n      newPosition = _getNewPosition.newPosition,\n      collision = _getNewPosition.collision,\n      movedDistance = _getNewPosition.movedDistance;\n    if (isHome) {\n      return getNextMonsterHomePosition(newPosition, monster, player);\n    }\n    return _objectSpread(_objectSpread({}, getNavigatedMonsterVector(newPosition, collision, movedDistance, monster, player)), {}, {\n      eatingTime: eatingTime\n    });\n  } catch (err) {\n    // wrapped or something\n    return {};\n  }\n}\nfunction animateMonster(state, time, player, monster, index) {\n  var _getNewMonsterVector = getNewMonsterVector(monster, player, time),\n    lost = _getNewMonsterVector.lost,\n    monsterVector = _objectWithoutProperties(_getNewMonsterVector, _excluded);\n  var newMonsters = state.monsters.slice();\n  newMonsters[index] = _objectSpread(_objectSpread({}, monster), monsterVector);\n  if (lost) {\n    return _objectSpread(_objectSpread({}, state), {}, {\n      lost: true\n    });\n  }\n  return _objectSpread(_objectSpread({}, state), {}, {\n    monsters: newMonsters\n  });\n}\nexport function animateMonsters(state, time, player) {\n  return state.monsters.reduce(function (lastState, monster, index) {\n    return animateMonster(lastState, time, player, monster, index);\n  }, state);\n}","map":{"version":3,"names":["_excluded","_objectWithoutProperties","source","excluded","target","_objectWithoutPropertiesLoose","key","i","Object","getOwnPropertySymbols","sourceSymbolKeys","length","indexOf","prototype","propertyIsEnumerable","call","sourceKeys","keys","ownKeys","object","enumerableOnly","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","toString","slice","constructor","name","Array","from","test","len","arr2","_i","Symbol","iterator","_arr","_n","_d","_s","_e","next","done","err","isArray","constants","tracks","gridDistance","orderPolarity","getNewPosition","snapToTrack","getAvailableVectors","_ref","newPosition","plane","trackTo","distanceFromTrack","movedDistance","availableOptions","player","eating","map","direction","_orderPolarity","optionPolarity","polarity","optionPlane","position","Math","max","compare","sort","_ref2","_ref3","posA","posB","pow","_ref4","getNextMonsterHomePosition","monster","EAST","MONSTER_HOME_EXIT_COL","WEST","NORTH","MONSTER_HOME_RANGE","directionBias","getIsHome","SOUTH","getAvailableMonsterRoutes","_ref5","collision","passedTrack","find","_ref6","_ref7","start","end","options","item","abs","getNavigatedMonsterVector","_orderPolarity2","order","Error","_getAvailableMonsterR","vectors","eatingTime","distanceFromPlayer","PLAYER_RADIUS","deadTime","MONSTER_DEATH_TIME_SECONDS","lost","getNewMonsterVector","time","startingPosition","startingDirection","isHome","speed","MONSTER_SPEED_RETREAT","MONSTER_SPEED_ATTACK","_getNewPosition","animateMonster","state","index","_getNewMonsterVector","monsterVector","newMonsters","monsters","animateMonsters","reduce","lastState"],"sources":["/Users/lordsmac/Documents/Dev/React_Play_Ground/Dashboard/Portfolio/portfolio/node_modules/react-pacman/dist/game/monster.js"],"sourcesContent":["var _excluded = [\"lost\"];\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport * as constants from '../constants';\nimport tracks from './tracks';\nimport { gridDistance, orderPolarity, getNewPosition, snapToTrack } from './movement';\n\nfunction getAvailableVectors(_ref) {\n  var newPosition = _ref.newPosition,\n      plane = _ref.plane,\n      trackTo = _ref.trackTo,\n      distanceFromTrack = _ref.distanceFromTrack,\n      movedDistance = _ref.movedDistance,\n      availableOptions = _ref.availableOptions,\n      player = _ref.player,\n      eating = _ref.eating;\n  return availableOptions.map(function (direction) {\n    var _orderPolarity = orderPolarity(direction),\n        optionPolarity = _orderPolarity.polarity,\n        optionPlane = _orderPolarity.plane;\n\n    var position = null;\n\n    if (plane === optionPlane) {\n      position = newPosition;\n    } else {\n      position = [];\n      position[optionPlane] = newPosition[optionPlane] + Math.max(0, movedDistance - distanceFromTrack) * optionPolarity;\n      position[1 - optionPlane] = trackTo;\n    }\n\n    var compare = [];\n    compare[optionPlane] = newPosition[optionPlane] + optionPolarity;\n    compare[1 - optionPlane] = position[1 - optionPlane];\n    return {\n      compare: compare,\n      position: position,\n      direction: direction\n    };\n  }).sort(function (_ref2, _ref3) {\n    var posA = _ref2.compare;\n    var posB = _ref3.compare;\n    return Math.pow(-1, eating >> 0) * (gridDistance(posA, player.position) - gridDistance(posB, player.position));\n  }).map(function (_ref4) {\n    var direction = _ref4.direction,\n        position = _ref4.position;\n    return {\n      direction: direction,\n      position: position\n    };\n  });\n}\n\nfunction getNextMonsterHomePosition(newPosition, monster, player) {\n  if (monster.direction === constants.EAST && monster.position[0] < constants.MONSTER_HOME_EXIT_COL && newPosition[0] >= constants.MONSTER_HOME_EXIT_COL || monster.direction === constants.WEST && monster.position[0] > constants.MONSTER_HOME_EXIT_COL && newPosition[0] <= constants.MONSTER_HOME_EXIT_COL) {\n    return {\n      position: [constants.MONSTER_HOME_EXIT_COL, newPosition[1]],\n      direction: constants.NORTH\n    };\n  }\n\n  if (monster.direction === constants.NORTH && monster.position[1] < constants.MONSTER_HOME_RANGE[constants.NORTH] && newPosition[1] >= constants.MONSTER_HOME_RANGE[constants.NORTH]) {\n    return {\n      position: [newPosition[0], constants.MONSTER_HOME_RANGE[constants.NORTH]],\n      direction: !monster.directionBias && monster.position[0] < player.position[0] ? constants.EAST : constants.WEST\n    };\n  }\n\n  return {\n    position: newPosition\n  };\n}\n\nfunction getIsHome(monster) {\n  return monster.position[0] > constants.MONSTER_HOME_RANGE[constants.WEST] && monster.position[0] < constants.MONSTER_HOME_RANGE[constants.EAST] && monster.position[1] > constants.MONSTER_HOME_RANGE[constants.SOUTH] && monster.position[1] < constants.MONSTER_HOME_RANGE[constants.NORTH];\n}\n\nfunction getAvailableMonsterRoutes(_ref5) {\n  var newPosition = _ref5.newPosition,\n      collision = _ref5.collision,\n      plane = _ref5.plane,\n      trackTo = _ref5.trackTo,\n      monster = _ref5.monster;\n  var availableOptions = [];\n  var distanceFromTrack = 0;\n\n  if (trackTo !== -1 && tracks[1 - plane][trackTo]) {\n    var passedTrack = tracks[1 - plane][trackTo].find(function (_ref6) {\n      var _ref7 = _slicedToArray(_ref6, 2),\n          start = _ref7[0],\n          end = _ref7[1];\n\n      return newPosition[1 - plane] >= start && newPosition[1 - plane] <= end;\n    });\n    var options = [null, null];\n\n    if (passedTrack[0] < newPosition[1 - plane]) {\n      options[0] = plane === 0 ? constants.SOUTH : constants.WEST;\n    }\n\n    if (passedTrack[1] > newPosition[1 - plane]) {\n      options[1] = plane === 0 ? constants.NORTH : constants.EAST;\n    }\n\n    availableOptions = options.filter(function (item) {\n      return item !== null;\n    });\n    distanceFromTrack = Math.abs(newPosition[plane] - trackTo);\n  }\n\n  if (!collision) {\n    availableOptions.push(monster.direction);\n  }\n\n  return {\n    availableOptions: availableOptions,\n    distanceFromTrack: distanceFromTrack\n  };\n}\n\nfunction getNavigatedMonsterVector(newPosition, collision, movedDistance, monster, player) {\n  // determine where to move a monster if it has a decision to make\n  var _orderPolarity2 = orderPolarity(monster.direction),\n      order = _orderPolarity2.order,\n      plane = _orderPolarity2.plane;\n\n  var trackTo = snapToTrack(plane, order, newPosition, movedDistance);\n\n  if (trackTo === -1 && collision) {\n    throw new Error('Collided but nothing to track to');\n  }\n\n  var _getAvailableMonsterR = getAvailableMonsterRoutes({\n    newPosition: newPosition,\n    collision: collision,\n    plane: plane,\n    trackTo: trackTo,\n    monster: monster\n  }),\n      availableOptions = _getAvailableMonsterR.availableOptions,\n      distanceFromTrack = _getAvailableMonsterR.distanceFromTrack;\n\n  if (!availableOptions.length) {\n    // this happens when wrapping\n    return {\n      position: newPosition\n    };\n  }\n\n  var vectors = getAvailableVectors({\n    newPosition: newPosition,\n    plane: plane,\n    trackTo: trackTo,\n    distanceFromTrack: distanceFromTrack,\n    movedDistance: movedDistance,\n    availableOptions: availableOptions,\n    player: player,\n    eating: monster.eatingTime > 0\n  });\n  var distanceFromPlayer = gridDistance(vectors[0].position, player.position);\n\n  if (distanceFromPlayer < constants.PLAYER_RADIUS * 1.8) {\n    if (monster.eatingTime) {\n      // monster got eaten\n      return {\n        deadTime: constants.MONSTER_DEATH_TIME_SECONDS\n      };\n    } // player got eaten\n\n\n    return {\n      lost: true\n    };\n  }\n\n  return vectors[0];\n}\n\nfunction getNewMonsterVector(monster, player, time) {\n  if (monster.deadTime > time) {\n    return _objectSpread(_objectSpread({}, monster), {}, {\n      deadTime: monster.deadTime - time\n    });\n  }\n\n  if (monster.deadTime > 0) {\n    return _objectSpread(_objectSpread({}, monster), {}, {\n      deadTime: 0,\n      eatingTime: 0,\n      position: monster.startingPosition,\n      direction: monster.startingDirection\n    });\n  }\n\n  var eatingTime = Math.max(0, monster.eatingTime - time);\n  var isHome = getIsHome(monster);\n  var speed = monster.eatingTime ? constants.MONSTER_SPEED_RETREAT : constants.MONSTER_SPEED_ATTACK;\n\n  try {\n    var _getNewPosition = getNewPosition(monster.position, monster.direction, speed, time, !isHome),\n        newPosition = _getNewPosition.newPosition,\n        collision = _getNewPosition.collision,\n        movedDistance = _getNewPosition.movedDistance;\n\n    if (isHome) {\n      return getNextMonsterHomePosition(newPosition, monster, player);\n    }\n\n    return _objectSpread(_objectSpread({}, getNavigatedMonsterVector(newPosition, collision, movedDistance, monster, player)), {}, {\n      eatingTime: eatingTime\n    });\n  } catch (err) {\n    // wrapped or something\n    return {};\n  }\n}\n\nfunction animateMonster(state, time, player, monster, index) {\n  var _getNewMonsterVector = getNewMonsterVector(monster, player, time),\n      lost = _getNewMonsterVector.lost,\n      monsterVector = _objectWithoutProperties(_getNewMonsterVector, _excluded);\n\n  var newMonsters = state.monsters.slice();\n  newMonsters[index] = _objectSpread(_objectSpread({}, monster), monsterVector);\n\n  if (lost) {\n    return _objectSpread(_objectSpread({}, state), {}, {\n      lost: true\n    });\n  }\n\n  return _objectSpread(_objectSpread({}, state), {}, {\n    monsters: newMonsters\n  });\n}\n\nexport function animateMonsters(state, time, player) {\n  return state.monsters.reduce(function (lastState, monster, index) {\n    return animateMonster(lastState, time, player, monster, index);\n  }, state);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}